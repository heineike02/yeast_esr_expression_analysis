# ------------------------------------------------------------------------------------------------------------------------
# ------------------------------------------------------------------------------------------------------------------------
# Remember to import regev_library before anything else to avoid matplotlib display issues on OSX
import regev_library
import numpy as np
import os
base_dir = os.path.normpath(os.path.dirname(os.getcwd()))
import sys
sys.path.append(base_dir + '/core')
import io_library
import matplotlib as mpl
import seaborn as sns
import matplotlib.pyplot as plt
import params
# ------------------------------------------------------------------------------------------------------------------------
# ------------------------------------------------------------------------------------------------------------------------
# 
# This library is largely deprecated. The single score metric (which gives a correlation score between two single
# conditions rather than cross-species) turned out to be pretty much useless. Maybe it can be useful in the future. 
# more importantly, some of the functions are still being used in cross_species_GO.py (like the check and create 
# function).
# 
# ------------------------------------------------------------------------------------------------------------------------
# ------------------------------------------------------------------------------------------------------------------------
def get_scores(seed_data, cross_data):
    """
    Calculates the single score data corresponding to the 
    genes determined by the seed_data and the conditions determined
    by the cross_data.

    Args:
        seed_data: Seed data used to generate the cross data
        cross_data: Cross-species data generated by the seed data

    Returns:
        score_data: The single score data for every condition/gene
                    as determined by seed data and cross data. 
    """

    score_data = {}

    # if 'Saccharomyces cerevisiae' in seed_data['Condition Key']:
        # ORF_gene_table, gene_ORF_table = io_library.read_SGD_features()

    for condition in cross_data:
        score_data[condition] = {}
        score_data[condition]['Genes'] = cross_data[condition]['Genes']
        score_data[condition]['Values'] = []
        score_data[condition]['Gene Map'] = cross_data[condition]['Gene Map']
        score_data[condition]['Value Map'] = {}
        score_data[condition]['Seed Gene Map'] = cross_data[condition]['Seed Gene Map']

        for seed_index, seed_value in enumerate(seed_data['Values']):
            seed_gene = seed_data['Genes'][seed_index]

            if seed_gene in cross_data[condition]['Seed Gene Map']:
                for current_gene in cross_data[condition]['Seed Gene Map'][seed_gene]:
                # for current_gene in cross_data[condition]['Genes']:
                    if current_gene != 'NONE':
                        # if 'Saccharomyces cerevisiae' in seed_data['Condition Key']:
                        #     current_gene = gene_ORF_table[current_gene_temp]
                        # else:
                        #     current_gene = current_gene_temp
                        # current_gene = current_gene_temp
                        # print cross_data[condition]['Gene Map']

                        raw_score = abs(cross_data[condition]['Gene Map'][current_gene] - seed_value)
                        # print raw_score
                        score_data[condition]['Values'].append(raw_score)
                        # print raw_score
                        if raw_score not in score_data[condition]['Value Map']:
                            score_data[condition]['Value Map'][raw_score] = current_gene
                        # elif len(score_data[condition]['Value Map']) == 1:
                        elif type(score_data[condition]['Value Map']) != type([]):
                            score_data[condition]['Value Map'][raw_score] = [score_data[condition]['Value Map'][raw_score] , current_gene]
                        else:
                            score_data[condition]['Value Map'][raw_score].append(current_gene)
                    
                    



            # raw_score = abs(cross_data[condition]['Values'][seed_index] - seed_value)
            # print raw_score
            # score_data[condition]['Values'].append(raw_score)
            # seed_gene = seed_data['Genes'][seed_index]
            # score_data[condition]['Value Map'][raw_score] = score_data[condition]['Genes'][seed_index] 

    # for seed_gene in seed_data['ORFs']:
        # print seed_data['Gene Map'][seed_gene]

    return score_data
# ------------------------------------------------------------------------------------------------------------------------
# ------------------------------------------------------------------------------------------------------------------------
def create_score_matrix(plotting_data, score_data, seed_data):
    """
    Similar to get_scores, but returns a simple matrix for use
    in plotting as opposed to a data structure as above.

    Args:
        seed_data: Seed data used to generate the cross data
        cross_data: Cross-species data generated by the seed data
        score_data: The cross-speices score data generated by 
                    get_scores above. 

    Returns:
        score_matrix: A raw matrix of score values for use in 
                      plotting.  
    """
    
    score_matrix_test = np.zeros(plotting_data.shape)

    max_val = 0.0
    for row_index, seed_value in enumerate(plotting_data[ : , 0]):
        for column_index, test_value in enumerate(plotting_data[ row_index , :]):
            score_matrix_test[row_index, column_index] = abs(test_value - seed_value)
            max_val = np.nanmax([max_val, abs(test_value) - seed_value])


    score_matrix_test = score_matrix_test / float(max_val)

    # print 'max_val = ' + str(max_val)

    num_columns = len(score_data) + 1

    # ---------------------------------------------------------
    # Running create plotting data on the score_data generated 
    # by the function above doesn't seem to be working, I'm not
    # sure why. But comparing the values in the score_data
    # with the matrix generated by using the original plotting
    # data here seem to match up fine
    # ---------------------------------------------------------

    # score_data_plot, score_data_labels_x, score_data_labels_y = regev_library.create_plotting_data(seed_data, score_data)
    # score_matrix = 1.0 - score_matrix
    # max_val = np.nanmax(score_matrix)

    # print 'max_val = ' + str(max_val)
    # score_matrix = score_matrix / float(max_val)

    score_matrix = score_matrix_test
    return score_matrix
# ------------------------------------------------------------------------------------------------------------------------
# ------------------------------------------------------------------------------------------------------------------------
def plot_score_matrix(score_matrix, plotting_labels_x, plotting_labels_y, seed_data):
    """
    Plots a matrix of cross-species score data. 

    Args:
        score_matrix: Matrix of cross-species score data generated by create_score_matrix
        plotting_labels_x: X labels (list of conditions)
        plotting_labels_y: Y labels (list of seed genes)
        seed_data: seed data used to generate cross-data and the score_matrix

    Returns:
        None
    """
    
    plotting_matrix = score_matrix[ :, 1: ]

    species_label_indices = np.ones(len(params.species_list))
    species_label_indices *= float('nan')
    # plotting_data_search = plotting_data[ : , 1: ]

    for species_index, species in enumerate(params.species_list):
        for condition_index, condition in enumerate(plotting_labels_x):
            if species in condition:
                species_label_indices[species_index] = condition_index
                break

    plotting_labels_x = regev_library.condense_labels(plotting_labels_x)
    plotting_labels_x = plotting_labels_x[1:]

    # num_columns = len(plotting_labels_x)
    num_columns = len(plotting_matrix[0, : ])
    # num_rows = len(plotting_labels_y)
    num_rows = len(plotting_matrix[ : , 0 ])
    # cmap = mpl.cm.RdBu_r
    cmap = mpl.cm.Blues
    cmap.set_bad('k',1.0)
    fig, ax = plt.subplots()
    ax = sns.heatmap(plotting_matrix, cmap = cmap, ax = ax, yticklabels = plotting_labels_y, xticklabels = plotting_labels_x)
    ylocs, ylabels = plt.yticks()
    plt.setp(ylabels, rotation = 0)
    xlocs, xlabels = plt.xticks()
    plt.setp(xlabels, rotation = 90)
    species_labels = []
    for species in params.species_list:
        species_labels.append(params.species_name_dict[species])
    newax = ax.twiny()
    for i in range(len(species_label_indices)):
        species_label_indices[i] = species_label_indices[i] / float(num_columns)
        # if i > 0:
        species_label_indices[i] -= 1 / float(num_columns)


# -----------------------------------------------------------------------------
    
    # high_genes = seed_data['High Genes']
    # high_genes_test = []
    # seed_species = params.get_species(params.condition_key)
    # if seed_species == 'Saccharomyces cerevisiae':
    #     ORF_gene_table, gene_ORF_table = io_library.read_SGD_features()
    #     for i in range(len(plotting_labels_y)):
    #         print 'here'
    #         if plotting_labels_y[i] in ORF_gene_table:
    #             high_genes_test.append(ORF_gene_table[plotting_labels_y[i]])
    #         else:
    #             high_gens_test.append(plotting_labels_y[i])
    # cutoff_index = 0
    # print high_genes_test
    # print plotting_labels_y
    # for label in plotting_labels_y:
    #     if label not in high_genes:
    #         if label != ' ':
    #             break
    #     cutoff_index += 1
    # print '----------------------------------------'
    # print cutoff_index
    # print '----------------------------------------'
    # cutoff_index = cutoff_index / float(num_rows)
    # cutoff_index -= 1 / float(num_rows)

# -----------------------------------------------------------------------------

    newax.set_xticklabels(species_labels)
    newax.set_xticks(species_label_indices)


    # newax2 = ax.twinx()
    # newax2.set_yticks([cutoff_index])
    # title = plt.title('Seed Condition ' + seed_data['Condition Key'])
    title = plt.title('Seed Condition ' + params.condition_key + '_' + str(params.HIGH_NUM) + '_' + str(params.LOW_NUM))
    title.set_y(1.05)
    plt.subplots_adjust(top=0.86)
    # title = 'Seed Condition ' + seed_data['Condition Key']
    # plt.text(0.5, 2, title, horizontalalignment = 'center', fontsize = 12)
    plt.tight_layout()
    plt.get_current_fig_manager().window.raise_()
    plt.show()
# ------------------------------------------------------------------------------------------------------------------------
# ------------------------------------------------------------------------------------------------------------------------
def check_and_create(high_num, low_num, condition_key, ext):
    """
    Checks if a previous set of seed_data_ cross_data, and labels has been 
    created for a given set of seed genes and target conditions (encapsulated by ext). 
    If the relevant structures have been created before, simply loads the existing structures to save time.
    If not, creates the new structures and saves them in stored_data folder. If structures appear to have been
    corrupted or saved incorrectly, can delete them manually and recompile using this method. 

    Args:
        high_num: If creating new data structures, the number of activated genes to use in the
                  seed data
        low_num: If creating new data structures, the number of repressed genes to use in the
                 seed data

    Returns:
        seed_data: Seed data corresponding to ext (or high_num/low_num + condition_key) if
                   it doesn't exist already.
        cross_data: Cross-species data corresponding to ext (or high_num/low_num + condition_key) if
                   it doesn't exist already.
        plotting_data: Plotting data corresponding to ext (or high_num/low_num + condition_key) if
                   it doesn't exist already.
        plotting_labels_x: X plotting labels corresponding to ext (or high_num/low_num + condition_key) if
                   it doesn't exist already.
        plotting_labels_y: Y plotting labels corresponding to ext (or high_num/low_num + condition_key) if
                   it doesn't exist already.
    """

    cwd = os.getcwd()
    # print cwd
    if os.path.exists(cwd + '/stored_data/' + ext):
        print '----------------------------------------------------'
        print 'LOADING DATA FROM FILES'
        print '----------------------------------------------------'
        seed_data = np.load(cwd + '/stored_data/' + ext + '/seed_data.npy')[()]
        cross_data = np.load(cwd + '/stored_data/' + ext + '/cross_data.npy')[()]
        plotting_data = np.load(cwd + '/stored_data/' + ext + '/plotting_data.npy')[()]
        plotting_labels_x = np.load(cwd + '/stored_data/' + ext + '/plotting_labels_x.npy')[()]
        plotting_labels_y = np.load(cwd + '/stored_data/' + ext + '/plotting_labels_y.npy')[()]

    else:
        print '----------------------------------------------------'
        print 'FILES NOT FOUND, CREATING NEW ONES'
        print '----------------------------------------------------'
        total_data, condition_list = regev_library.compile_total_data()
        

        # Still need to incorporate functionality for name mode into this code, should be quick
        seed_gene_list = []
        seed_data = regev_library.get_seed_data(high_num, low_num, seed_gene_list, total_data, condition_key)
        cross_data = regev_library.create_cross_data(seed_data, total_data, condition_list)
        plotting_data, plotting_labels_x, plotting_labels_y = regev_library.create_plotting_data(seed_data, cross_data)

        os.mkdir('./stored_data/' + ext)
        np.save('./stored_data/' + ext + '/seed_data', seed_data)
        np.save('./stored_data/' + ext + '/cross_data', cross_data)
        np.save('./stored_data/' + ext + '/plotting_data', plotting_data)
        np.save('./stored_data/' + ext + '/plotting_labels_x', plotting_labels_x)
        np.save('./stored_data/' + ext + '/plotting_labels_y', plotting_labels_y)

    print '----------------------------------------------------'
    print 'DONE'
    print '----------------------------------------------------'

    return seed_data, cross_data, plotting_data, plotting_labels_x, plotting_labels_y


# ------------------------------------------------------------------------------------------------------------------------
# ------------------------------------------------------------------------------------------------------------------------